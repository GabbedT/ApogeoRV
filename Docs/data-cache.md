# Data Cache

RV32-Apogeo implements an highly parametrizable data cache to get faster accesses to the memory. 

The base parameters are: 

Parameter | Value | 
--- | --- | 
Total size    | 16KB |
Block width   | 128 bits
Associativity | 4 ways

Given that, the address generated by the CPU will have the following values: 

Range | Name | Description |
--- | --- | --- |
[31:12] | Tag         | Used to check the entry against the data in the ways
[11:4]  | Index       | Used to access the actual cache
[3:2]   | Chip select | Used to access one of the N data banks
[1:0]   | Byte select | Used to access a byte (in byte operations)

---

&nbsp;

## Cache Memory 

The cache is not composed only by the memory. There are also component that controls the cache traffic and memory traffic: 

* [Store controller](#stor-controller) 
* [Load controller](#load-controller) 
* Cache hit checker
* Port 0 arbiter
* [Cache memory block](#memory-design)

The cache then is directly connected the the **Load Store Unit** which resides in the *Execution unit* in the main pipeline, to the **store buffer** and the **memory controller**

![Cache Diagram](../Images/DataCacheDiagram.png)

&nbsp;

### Memory design 

As said the cache configuration is 4-way, 16KB with 128 bit (16 bytes) wide data block. 

Each way has 4KB of data divided by the block bytes, we find that the total cache entries are 256 (8 bit index).

For *loads miss* the cache has **early restart mode**, which means that as soon the right block requested arrives from external memory it will be supplied to the load unit while the cache line is being allocated. Also **write back** dirty lines when replacing them.

For *store miss* the cache simply write the data directly in memory (**write no allocate**). The cache will write the data into a **store buffer** and the memory controller will take care of it.


The memory has two ports: **PORT 0** is a **R/W** port and it is used mainly by the store unit controller to write data in cache, load unit controller will use this port to allocate a new cache line in case of a load miss. **PORT 0** usage is arbitrated by appropriate arbiter logic. 

**PORT 1** is a **R** only port and it is exclusively used by load unit controller.

Each port has an appropriate hit logic block connected to the controllers.

The cache is composed by **4 ways**, a way is composed by:

* Status bits
* Tag bits
* Data bits

During a cache read, all the ways are accessed at the same time since the 4 tags needs to be compared to the CPU address. During a write only one way must be written, this is done thanks to enable bits.

*PORT 0* **read packets** are composed of: 

* Valid bit
* Tag

Because **store controller** only needs to know if the access is an hit or a miss.

*PORT 1* **read packets** are composed of:

* Valid bit
* Dirty bit
* Tag 
* Data

Because **load controller** needs to know if the access is an hit or a miss and thus if the data is valid or not. Also dirty bit is needed to know if writeback the block during reallocation.

![Data Cache Ways](../Images/DataCacheWays.png)

&nbsp;

### Data block 

To lower the energy consumption and access time the block is divided in 4 different banks 32 bits wide to match **XLEN**, accessed by the [3:2] bits of the address generated by the CPU. By that we add a little bit of decoding logic but lower drastically the memory design complexity.

The block memory has 2 ports: **PORT 0** has only write capabilities (with byte write port), **PORT 1** has only read capabilities.
The reason why **PORT 0** is a write only port is because the store unit doesn't need to read any data.

![Data Block](../Images/CacheBlock.png)

&nbsp;

### Status and tag 

To know if the cache location accessed correspond to the address generated a valid bit and a tag are needed. Both set of bits are stored in a memory with two ports: **PORT 0** is a **R/W** port, **PORT 1** is **R** only.

On read the tag is compared with the high address bits ([31:12]), the result is anded (&) with the valid bit, this determine if the access is an hit or a miss.

At startup all the cache lines are set as invalid (valid bit = 0).

The dirty bit is used to know if the memory location corresponding to that cache line is up to date or not. If not, during a load miss, before a new line is allocated, the old cache line get written back into the memory.

---

&nbsp;

## Store Controller

The **store controller** works closely with the **store unit**, his job is to:

* Store data in cache
* Store data in memory
* Invalidate a cache line
* Check store validity

### Cache Store 


### Memory Store


### Invalidation


### Check Validity

---

&nbsp;

## Load Unit Controller