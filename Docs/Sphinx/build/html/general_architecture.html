<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>General Architecture &mdash; Apogeo Documentation 20/05/2023 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Control Status Registers" href="control_status_registers.html" />
    <link rel="prev" title="External Interface" href="external_interface.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Apogeo Documentation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="external_interface.html">External Interface</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">General Architecture</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#instruction-set-architecture">Instruction Set Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pipeline-general-description">Pipeline General Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-map">Memory Map</a></li>
<li class="toctree-l2"><a class="reference internal" href="#input-output">Input Output</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="control_status_registers.html">Control Status Registers</a></li>
<li class="toctree-l1"><a class="reference internal" href="interrupts_and_exceptions.html">Interrupts And Exceptions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Apogeo Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">General Architecture</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/general_architecture.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="general-architecture">
<h1>General Architecture<a class="headerlink" href="#general-architecture" title="Permalink to this heading"></a></h1>
<p>ApogeoCore’s architecture is designed to be exceptionally well balanced in terms of <em>performace / area / power</em> tradeoff.
By strategically selecting ISA and selecting the right microarchitectural choices, the initial priority target of low power and low area has been archieved.</p>
<p>In the later paragraphs there is a description of every important architectural detail</p>
<section id="instruction-set-architecture">
<h2>Instruction Set Architecture<a class="headerlink" href="#instruction-set-architecture" title="Permalink to this heading"></a></h2>
<p>The ISA (Instruction Set Architecture) of a CPU <strong>define a set of rules and specifications</strong> that a CPU <strong>must</strong> adhere to be able to execute programs compiled for that ISA.
If the CPU doesn’t follow the standard behaviour defined by the ISA under specific circumstances, there will be a lot of problems when executing code.</p>
<p>The following list covers the main points that an ISA specify:</p>
<ul class="simple">
<li><p><strong>Instructions</strong>: Define the instructions that the CPU can execute, their type and behaviour.</p></li>
<li><p><strong>Instruction Encoding</strong>: Define the instruction word size and how it can be decoded into a set of signals / micro operation that can be understood by the CPU.</p></li>
<li><p><strong>Data Type</strong>: Specifies the data types that the CPU can manipulate.</p></li>
<li><p><strong>Registers</strong>: Define the number and the width of the main architectural registers, the width also defines the data size.</p></li>
<li><p><strong>Exceptions and Interrupts</strong>: How the core must react to special events.</p></li>
<li><p><strong>Privilege Levels</strong>: Many modern CPUs have multiple privilege levels, which determine the level of access and control that different software components (e.g., user applications, the operating system) have over the hardware. The ISA specifies how these privilege levels work.</p></li>
</ul>
<p>Given the open source nature of this project, the obvious choice for the CPU Instruction Set Architecture is: <strong>RISC-V</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RISC-V Official Site: <a class="reference external" href="https://riscv.org/">here</a></p>
</div>
<p>RISC-V is an <strong>open source and royalty-free</strong> instruction set architecture (ISA) that has gained significant attention and popularity in recent years. Because of this, RISC-V has obtained a lot of support and a wide variety of tools
and softwares has been produced, as well as a great amount of online documentation in both hardware and software.</p>
<p>RISC-V has a lot of benefit othen than being open source. It’s easy to learn, which makes it suitable for an academic project. Thanks to the ISA specifications, in particular:</p>
<ul class="simple">
<li><p><strong>Simple Instruction Encoding</strong></p></li>
<li><p><strong>Relaxed Memory Model</strong></p></li>
<li><p><strong>Reduced Number of Instructions</strong></p></li>
</ul>
<p>CPUs can be really simple yet powerful. Also thanks to the multitude of extensions, the designer can choose the best ISA subset that suits a particular target application.
The extensions used for ApogeoCore are:</p>
<ul class="simple">
<li><p><strong>M Extension</strong>: Multiplication and division are found in almost every program, these are operation that can take more than 100 / 1000 cycles if implemented in software.</p></li>
<li><p><strong>B Subsets (Zba, Zbb, Zbs)</strong>: The Bitmanip extension is helpful to speedup a lot of tasks: string processing, soft float, endiannes inversion, IO operations etc. The <strong>Zbc</strong> was not included because the instructions of this subset are not often used and use a lot of hardware resources.</p></li>
<li><p><strong>C Extension</strong>: Compresses executable programs, making it particularly useful for systems with limited available memory.</p></li>
<li><p><strong>Zfinx Extension</strong>: Enable the use of floating point instructions on integer registers only. This is particularly useful to reduce code size and speedup floating point computations without having a large area overhead (especially on OoO machines)</p></li>
</ul>
</section>
<section id="pipeline-general-description">
<h2>Pipeline General Description<a class="headerlink" href="#pipeline-general-description" title="Permalink to this heading"></a></h2>
<p>In digital system the technique of pipelining is used to increase the working clock frequency and the throughput. By splitting a task into multiple stages that execute
a particular section of the original task we can shorten the critical path thus increasing the frequency. The stages are separated using memory components like flip flops and
latches, because of this the drawback of pipelining is the increased latency. If the pipeline has N stages, the result of an operation will be available after exactly N clock cycles
if there are no interruptions.</p>
<p>The standard CPU instruction cycle consist in 4 different stages:</p>
<ul class="simple">
<li><p><strong>Fetch</strong>: The instruction is fetched from memory.</p></li>
<li><p><strong>Decode</strong>: The fetched instruction is decoded, control signals and micro operations are encoded here.</p></li>
<li><p><strong>Execute</strong>: The instruction gets executed.</p></li>
<li><p><strong>Writeback</strong>: The result is written back into the register file.</p></li>
</ul>
<p>This is great for pipelining, however in more complex processors, more pipeline stages needs to be added. ApogeoCore, implements the following pipeline stages:</p>
<dl>
<dt><strong>PC Generation</strong>:</dt><dd><p>Here the <em>program counter</em> is generated based on the control signals that comes from the execute stage / branch predictor and sent to the memory. Meanwhile the same address is feeded into the <strong>branch target buffer</strong>. The
branch target buffer (or BTB) is a cache that holds the target addresses of the branches that are encountered during program execution. It is indexed by the lower part of the address, in the next cycle the tag (upper part of the address)
is readed along with the <strong>branch target address</strong> (BTA), if the tag and the upper part of the address match, the BTA is valid and it’s sent to the <strong>branch predictor</strong>. Here the current <strong>global branch history</strong> saved in a shift register,
is XORed with the PC of the previous cycle, the resulting hashed address is used as an index for the <strong>predictor table</strong>. This is a memory that holds the current prediction associated with a branch. Once the prediction is made, the prediction
info is pushed into a FIFO buffer waiting for execute stage to produce the right branch outcome.</p>
<p>In this stage the arriving instruction, fetch addresses and if the instruction is predicted or not gets pushed inside the <strong>instruction buffer</strong>.</p>
</dd>
<dt><strong>Fetch</strong>:</dt><dd><p>The instruction gets fetched from the instruction buffer. In case of a compressed instruction, this gets decompressed into the corresponding 32 bit instruction. Here resides the logic to resolve misaligned instructions, since the CPU enable the
usage of 16 bit compressed instruction. If a 16 bit instruction is at address 0x00000000 and a 32 bit instruction follows it, the 32 bit instruction is misaligned.</p>
</dd>
<dt><strong>Decode</strong>:</dt><dd><p>The instruction is simply decoded and a set of control signals is generated.</p>
</dd>
<dt><strong>Issue</strong>:</dt><dd><p>Data dependencies are resolved inside the <strong>scoreboard</strong>, a structure that holds all the functional units status:
* Cycles remaining to produce a valid result.
* Register destination.
* Idle unit status for non pipelined units.</p>
<p>operands are fowarded from the <strong>writeback stage</strong> or read from the <strong>register file</strong>. The instruction packets get assembled to carry informations of the instruction down the pipeline.</p>
</dd>
</dl>
<ul class="simple">
<li><dl class="simple">
<dt><strong>Bypass / Foward</strong>:</dt><dd><p>Operands are simply fowarded from the later stages.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Execute</strong>: Instructions get executed and branch target addresses / memory addresses are resolved.</dt><dd><p>Here reside the functional units that perform operations to execute instructions:</p>
<ul>
<li><p><strong>ALU</strong>: Arithmetic Logic Unit, it execute every RV32I instructions (except for load and store), it is fully combinational.</p></li>
<li><p><strong>MUL</strong>: Multiplication Unit, it execute every multiplication instruction of RV32M, it is pipelined and the latency of the multiplier can be configured.</p></li>
<li><p><strong>DIV</strong>: Division Unit, a multicycle unit that execute every division instruction of RV32M. It can accept only one operation until it finish it’s task.</p></li>
<li><p><strong>BMU</strong>: Bit Manipulation Unit, a pipelined unit that execute every RV32B instruction.</p></li>
<li><p><strong>LSU</strong>: Load Store Unit, handles memory operations.</p></li>
<li><p><strong>CSRU</strong>: Control Status Register Unit, holds the logic to handle CSR instructions.</p></li>
<li><p><strong>FPU</strong>: Floating Point Unit, handles floating point instructions.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p><strong>Commit</strong>: Buffer stage to avoid structural hazards since the LSU and the other units could produce a valid result simultaneously. The result is valid here.</p></li>
<li><p><strong>Reorder</strong>: Instruction packets get reordered because of the Out Of Order execution.</p></li>
<li><p><strong>Writeback</strong>: Instruction results are written back into the register file <em>in order</em>. Exceptions get caught here.</p></li>
</ul>
</section>
<section id="memory-map">
<h2>Memory Map<a class="headerlink" href="#memory-map" title="Permalink to this heading"></a></h2>
<p>The CPU’s memory map is a simplified structure with predefined memory regions, each having specific characteristics. This simplicity helps keep the CPU hardware straightforward and provides flexibility
to system designers who can customize their own memory map on top of the existing structure. The regions are predefined but their size can be modified by modifying the parameters
inside the <cite>apogeo_memory_map.svh</cite> file.</p>
<p>Starting from <cite>0x00000000</cite> there is the <strong>Boot Region</strong>, This is where the CPU begins execution after a reset. The program counter is set to <cite>0x00000000.</cite>, here is located the <strong>boot program</strong>. The main task of this program is usually
to initialize registers, CSRs, system hardware etc.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This region is only accessable by <strong>M mode code</strong>. A store instruction inside the region boundaries will result in a <strong>store access fault</strong> exception.</p>
</div>
<p>After the Boot Region, the <strong>Private Region</strong> is found. This region encloses a portion of <strong>general-purpose memory</strong> and the <strong>IO Region</strong>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This entire region is only accessable by <strong>M mode code</strong>.</p>
</div>
<p>The <strong>IO Region</strong> is located at the lowest address of the Private Region, here all the <strong>MMIO (Memory Mapped Input Output) Registers</strong> reside and can be accessed by load and stores instructions.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Memory operations inside IO Region must not be cached!</p>
</div>
<p>After the IO Region, a general purpouse privileged memory region is found. Here code and data can be stored and accessed freely. It is typically used by privileged software components.</p>
<p>The last is the unprivileged general purpouse memory region or <strong>User Memory Region</strong>. This is intended for user mode (U mode) code and data. It allows for the storage and retrieval of user-level programs and data.</p>
</section>
<section id="input-output">
<h2>Input Output<a class="headerlink" href="#input-output" title="Permalink to this heading"></a></h2>
<p>As stated before, the Input Output devices are accessed through <strong>memory mapped registers</strong>, which mean that a load / store request at a particular address does not access
the memory but a control register of the IO device. In essence, memory-mapped registers provide a standardized way for the CPU to communicate with IO devices by treating them as if they were part of the memory. This abstraction
simplifies software development and system design, allowing for a more uniform and efficient interaction with various hardware components.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The logic for this must be implemented by the system designer.</p>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="external_interface.html" class="btn btn-neutral float-left" title="External Interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="control_status_registers.html" class="btn btn-neutral float-right" title="Control Status Registers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tripi Gabriele.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>