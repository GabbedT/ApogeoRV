# This script acceept three path for files: 
#
#   - First argument: trace file relative path
#   - Second argument: disassembly file relative path
#   - Third argument: output file relative path
#
# The script read saves locally the entire disassembly file, then it reads line by line the
# trace file generated by the CPU testbench. It then combines the two files into a single 
# file output that contains the following fields: 
#
# TIMESTAMP | ADDRESS | INSTRUCTION HEX | INSTRUCTION ASSEMBLY | RESULT |


import sys

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


if len(sys.argv) != 4: 
    print(bcolors.FAIL + "[ERROR] Wrong argument number" + bcolors.ENDC)
    print(bcolors.OKCYAN + "[HINT] First argument: trace file relative path")
    print(bcolors.OKCYAN + "[HINT] Second argument: disassembly file relative path")
    print(bcolors.OKCYAN + "[HINT] Third argument: output file relative path")
    sys.exit(1)


traceFilePath = sys.argv[1]
disassemblyFilePath = sys.argv[2]
outputFilePath = sys.argv[3]

try:
    print("[INFO] Opening disassembly file...")
    disassemblyFile = open(disassemblyFilePath) 
    print("[INFO] Done!")

    # Save the entire disassembly file 
    disassembly = disassemblyFile.readlines()

except FileNotFoundError:
    print(bcolors.FAIL + "[ERROR] File not found!")
    sys.exit(1)

finally: 
    disassemblyFile.close() 


# Fields read from files
timestampField = []
addressFields = []
resultFields = []
disassemblyFields = []

# Number of lines for trace file 
times = 0


try:
    print("[INFO] Opening trace file...")

    with open(traceFilePath, 'r') as trace: 
        print(bcolors.OKGREEN + "[INFO] Done!" + bcolors.ENDC)

        for line in trace: 
            # Divide each line in fields 
            fields = line.strip().split("|")

            # Save timestamp and address
            timestampField.append(fields[0].strip()) 
            addressFields.append(fields[1].strip())
            resultFields.append(fields[3].strip())

            print(fields[3].strip())

            # Get the address from hexadecimal in integer
            address = int(fields[1].strip(), 16)

            # Divide the given hexadecimal by 4 to get the address line into the disassembly file, 
            # replace each TAB character with a space
            disassemblyLine = disassembly[address // 4].strip().replace("\t", " ")

            # Get the instruction hexadecimal value with the literal translation
            fields = disassemblyLine.strip().split(":")
            disassemblyFields.append(fields[1])

            times += 1

except FileNotFoundError:
    print(bcolors.FAIL + "[ERROR] File not found!")
    sys.exit(1)



with open(outputFilePath, 'w') as out:
    print("[INFO] Writing final trace...")

    for i in range(times):
        # Write the output file 
        out.write(str(timestampField[i]) + "  |  " + str(addressFields[i]) + "  | " + str(disassemblyFields[i]) + "  |  " + str(resultFields[i]) + "\n") 

print(bcolors.OKGREEN + "[INFO] Done!" + bcolors.ENDC)